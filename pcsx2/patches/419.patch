From aba0a098162416fe22cb015a6b23197e95186147 Mon Sep 17 00:00:00 2001
From: Gregory Hainaut <gregory.hainaut@gmail.com>
Date: Mon, 5 Jan 2015 23:38:30 +0100
Subject: [PATCH 1/6] pcsx2 64b: fix crash on string formating function

Call to vsnprintf update the gp_offset of the varargs (at least on x86_64 linux).
Therefore the 2nd call (because buffer was too small) uses out-of-memory arguments

We need to keep a local copy otherwise you will get an awful SIGSEV

Note: I'm sure we have same issue on plugins
---
 common/src/Utilities/FastFormatString.cpp | 12 ++++++++++--
 1 file changed, 10 insertions(+), 2 deletions(-)

diff --git a/common/src/Utilities/FastFormatString.cpp b/common/src/Utilities/FastFormatString.cpp
index c444b01..477836e 100644
--- a/common/src/Utilities/FastFormatString.cpp
+++ b/common/src/Utilities/FastFormatString.cpp
@@ -153,10 +153,14 @@ static GlobalBufferManager< BaseTlsVariable< FastFormatBuffers > > m_buffer_tls(
 //static __ri void format_that_ascii_mess( SafeArray<char>& buffer, uint writepos, const char* fmt, va_list argptr )
 static __ri void format_that_ascii_mess( CharBufferType& buffer, uint writepos, const char* fmt, va_list argptr )
 {
+	va_list args;
 	while( true )
 	{
 		int size = buffer.GetLength();
-		int len = vsnprintf(buffer.GetPtr(writepos), size-writepos, fmt, argptr);
+
+		va_copy(args, argptr);
+		int len = vsnprintf(buffer.GetPtr(writepos), size-writepos, fmt, args);
+		va_end(args);
 
 		// some implementations of vsnprintf() don't NUL terminate
 		// the string if there is not enough space for it so
@@ -184,10 +188,14 @@ static __ri void format_that_ascii_mess( CharBufferType& buffer, uint writepos,
 // returns the length of the formatted string, in characters (wxChars).
 static __ri uint format_that_unicode_mess( CharBufferType& buffer, uint writepos, const wxChar* fmt, va_list argptr)
 {
+	va_list args;
 	while( true )
 	{
 		int size = buffer.GetLength() / sizeof(wxChar);
-		int len = wxVsnprintf((wxChar*)buffer.GetPtr(writepos*sizeof(wxChar)), size-writepos, fmt, argptr);
+
+		va_copy(args, argptr);
+		int len = wxVsnprintf((wxChar*)buffer.GetPtr(writepos*sizeof(wxChar)), size-writepos, fmt, args);
+		va_end(args);
 
 		// some implementations of vsnprintf() don't NUL terminate
 		// the string if there is not enough space for it so

From e447ffc8b2f0ac3cddd189c2bf469c1972622400 Mon Sep 17 00:00:00 2001
From: Gregory Hainaut <gregory.hainaut@gmail.com>
Date: Mon, 5 Jan 2015 00:24:37 +0100
Subject: [PATCH 2/6] cmake: fix asan on 64 bits

---
 cmake/BuildParameters.cmake | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/cmake/BuildParameters.cmake b/cmake/BuildParameters.cmake
index 82d5240..b70158e 100644
--- a/cmake/BuildParameters.cmake
+++ b/cmake/BuildParameters.cmake
@@ -238,7 +238,10 @@ elseif(CMAKE_BUILD_TYPE MATCHES "Release")
 endif()
 
 if (USE_ASAN)
-    set(ASAN_FLAG "-fsanitize=address -fno-omit-frame-pointer -g -mpreferred-stack-boundary=4 -mincoming-stack-boundary=2 -DASAN_WORKAROUND")
+    set(ASAN_FLAG "-fsanitize=address -fno-omit-frame-pointer -g -DASAN_WORKAROUND")
+    if(${PCSX2_TARGET_ARCHITECTURES} MATCHES "i386")
+        set(ASAN_FLAG "${ASAN_FLAG} -mpreferred-stack-boundary=4 -mincoming-stack-boundary=2")
+    endif()
 else()
     set(ASAN_FLAG "")
 endif()

From 04ca7f4a2b5cea957443479257db27b766f82c45 Mon Sep 17 00:00:00 2001
From: Gregory Hainaut <gregory.hainaut@gmail.com>
Date: Mon, 5 Jan 2015 00:25:37 +0100
Subject: [PATCH 3/6] common: 64 bits intrinsic fixes

long is 8B on linux. Replace it with s32
long long is always 8B but let's replace it with s64 so we are sure
---
 common/include/Utilities/General.h          |  2 +-
 common/include/Utilities/PersistentThread.h |  4 ++--
 common/include/intrin_x86.h                 | 19 ++++++++++++------
 common/src/Utilities/Mutex.cpp              |  2 +-
 common/src/Utilities/ThreadTools.cpp        | 30 ++++++++++++++---------------
 5 files changed, 32 insertions(+), 25 deletions(-)

diff --git a/common/include/Utilities/General.h b/common/include/Utilities/General.h
index 54e0afd..ce534f0 100644
--- a/common/include/Utilities/General.h
+++ b/common/include/Utilities/General.h
@@ -111,7 +111,7 @@ class IDeletableObject
 class BaseDeletableObject : public virtual IDeletableObject
 {
 protected:
-	volatile long	m_IsBeingDeleted;
+	volatile s32	m_IsBeingDeleted;
 
 public:
 	BaseDeletableObject();
diff --git a/common/include/Utilities/PersistentThread.h b/common/include/Utilities/PersistentThread.h
index 7abc454..59fb7da 100644
--- a/common/include/Utilities/PersistentThread.h
+++ b/common/include/Utilities/PersistentThread.h
@@ -103,8 +103,8 @@ namespace Threading
 		MutexRecursive	m_mtx_start;	// used to lock the Start() code from starting simultaneous threads accidentally.
 		Mutex		m_mtx_ThreadName;
 
-		volatile long m_detached;		// a boolean value which indicates if the m_thread handle is valid
-		volatile long m_running;		// set true by Start(), and set false by Cancel(), Block(), etc.
+		volatile s32 m_detached;		// a boolean value which indicates if the m_thread handle is valid
+		volatile s32 m_running;		// set true by Start(), and set false by Cancel(), Block(), etc.
 
 		// exception handle, set non-NULL if the thread terminated with an exception
 		// Use RethrowException() to re-throw the exception using its original exception type.
diff --git a/common/include/intrin_x86.h b/common/include/intrin_x86.h
index 76aec49..2755b28 100644
--- a/common/include/intrin_x86.h
+++ b/common/include/intrin_x86.h
@@ -54,34 +54,41 @@
 
 /*** Atomic operations ***/
 
-static __inline__ __attribute__((always_inline)) long _InterlockedCompareExchange(volatile long * const Destination, const long Exchange, const long Comperand)
+static __inline__ __attribute__((always_inline)) s32 _InterlockedCompareExchange(volatile s32 * const Destination, const s32 Exchange, const s32 Comperand)
 {
 	return __sync_val_compare_and_swap(Destination, Comperand, Exchange);
 }
 
-static __inline__ __attribute__((always_inline)) long long _InterlockedCompareExchange64(volatile long long * const Destination, const long long Exchange, const long long Comperand)
+static __inline__ __attribute__((always_inline)) s64 _InterlockedCompareExchange64(volatile s64 * const Destination, const s64 Exchange, const s64 Comperand)
 {
 	return __sync_val_compare_and_swap(Destination, Comperand, Exchange);
 }
 
-static __inline__ __attribute__((always_inline)) long _InterlockedExchange(volatile long * const Target, const long Value)
+static __inline__ __attribute__((always_inline)) s32 _InterlockedExchange(volatile s32 * const Target, const s32 Value)
 {
 	/* NOTE: __sync_lock_test_and_set would be an acquire barrier, so we force a full barrier */
 	__sync_synchronize();
 	return __sync_lock_test_and_set(Target, Value);
 }
 
-static __inline__ __attribute__((always_inline)) long _InterlockedExchangeAdd(volatile long * const Addend, const long Value)
+static __inline__ __attribute__((always_inline)) s64 _InterlockedExchange64(volatile s64 * const Target, const s64 Value)
+{
+	/* NOTE: __sync_lock_test_and_set would be an acquire barrier, so we force a full barrier */
+	__sync_synchronize();
+	return __sync_lock_test_and_set(Target, Value);
+}
+
+static __inline__ __attribute__((always_inline)) s32 _InterlockedExchangeAdd(volatile s32 * const Addend, const s32 Value)
 {
 	return __sync_fetch_and_add(Addend, Value);
 }
 
-static __inline__ __attribute__((always_inline)) long _InterlockedDecrement(volatile long * const lpAddend)
+static __inline__ __attribute__((always_inline)) s32 _InterlockedDecrement(volatile s32 * const lpAddend)
 {
 	return _InterlockedExchangeAdd(lpAddend, -1) - 1;
 }
 
-static __inline__ __attribute__((always_inline)) long _InterlockedIncrement(volatile long * const lpAddend)
+static __inline__ __attribute__((always_inline)) s32 _InterlockedIncrement(volatile s32 * const lpAddend)
 {
 	return _InterlockedExchangeAdd(lpAddend, 1) + 1;
 }
diff --git a/common/src/Utilities/Mutex.cpp b/common/src/Utilities/Mutex.cpp
index 5356d11..abdae8e 100644
--- a/common/src/Utilities/Mutex.cpp
+++ b/common/src/Utilities/Mutex.cpp
@@ -23,7 +23,7 @@
 
 namespace Threading
 {
-	static long					_attr_refcount = 0;
+	static s32					_attr_refcount = 0;
 	static pthread_mutexattr_t	_attr_recursive;
 }
 
diff --git a/common/src/Utilities/ThreadTools.cpp b/common/src/Utilities/ThreadTools.cpp
index 6493c80..bd679d0 100644
--- a/common/src/Utilities/ThreadTools.cpp
+++ b/common/src/Utilities/ThreadTools.cpp
@@ -797,52 +797,52 @@ __fi s32 Threading::AtomicRead(volatile s32& Target) {
 }
 
 __fi u32 Threading::AtomicExchange(volatile u32& Target, u32 value ) {
-	return _InterlockedExchange( (volatile long*)&Target, value );
+	return _InterlockedExchange( (volatile s32*)&Target, value );
 }
 __fi s32 Threading::AtomicExchange( volatile s32& Target, s32 value ) {
-	return _InterlockedExchange( (volatile long*)&Target, value );
+	return _InterlockedExchange( (volatile s32*)&Target, value );
 }
 
 __fi u32 Threading::AtomicExchangeAdd( volatile u32& Target, u32 value ) {
-	return _InterlockedExchangeAdd( (volatile long*)&Target, value );
+	return _InterlockedExchangeAdd( (volatile s32*)&Target, value );
 }
 __fi s32 Threading::AtomicExchangeAdd( volatile s32& Target, s32 value ) {
-	return _InterlockedExchangeAdd( (volatile long*)&Target, value );
+	return _InterlockedExchangeAdd( (volatile s32*)&Target, value );
 }
 
 __fi s32 Threading::AtomicExchangeSub( volatile s32& Target, s32 value ) {
-	return _InterlockedExchangeAdd( (volatile long*)&Target, -value );
+	return _InterlockedExchangeAdd( (volatile s32*)&Target, -value );
 }
 
 __fi u32 Threading::AtomicIncrement( volatile u32& Target ) {
-	return _InterlockedExchangeAdd( (volatile long*)&Target, 1 );
+	return _InterlockedExchangeAdd( (volatile s32*)&Target, 1 );
 }
 __fi s32 Threading::AtomicIncrement( volatile s32& Target) {
-	return _InterlockedExchangeAdd( (volatile long*)&Target, 1 );
+	return _InterlockedExchangeAdd( (volatile s32*)&Target, 1 );
 }
 
 __fi u32 Threading::AtomicDecrement( volatile u32& Target ) {
-	return _InterlockedExchangeAdd( (volatile long*)&Target, -1 );
+	return _InterlockedExchangeAdd( (volatile s32*)&Target, -1 );
 }
 __fi s32 Threading::AtomicDecrement(volatile s32& Target) {
-	return _InterlockedExchangeAdd((volatile long*)&Target, -1);
+	return _InterlockedExchangeAdd((volatile s32*)&Target, -1);
 }
 
 __fi void* Threading::_AtomicExchangePointer(volatile uptr& target, uptr value)
 {
-#ifdef _M_AMD64		// high-level atomic ops, please leave these 64 bit checks in place.
-	return (void*)_InterlockedExchange64(&(volatile s64&)target, value);
+#ifdef _M_X86_64		// high-level atomic ops, please leave these 64 bit checks in place.
+	return (void*)_InterlockedExchange64((volatile s64*)&target, value);
 #else
-	return (void*)_InterlockedExchange((volatile long*)&target, value);
+	return (void*)_InterlockedExchange((volatile s32*)&target, value);
 #endif
 }
 
 __fi void* Threading::_AtomicCompareExchangePointer(volatile uptr& target, uptr value, uptr comparand)
 {
-#ifdef _M_AMD64		// high-level atomic ops, please leave these 64 bit checks in place.
-	return (void*)_InterlockedCompareExchange64(&(volatile s64&)target, value);
+#ifdef _M_X86_64		// high-level atomic ops, please leave these 64 bit checks in place.
+	return (void*)_InterlockedCompareExchange64((volatile s64*)&target, value, comparand);
 #else
-	return (void*)_InterlockedCompareExchange(&(volatile long&)target, value, comparand);
+	return (void*)_InterlockedCompareExchange((volatile s32*)&target, value, comparand);
 #endif
 }
 

From 3f521cc7a0131bb75738d32917054f56dc729623 Mon Sep 17 00:00:00 2001
From: Gregory Hainaut <gregory.hainaut@gmail.com>
Date: Mon, 5 Jan 2015 23:59:08 +0100
Subject: [PATCH 4/6] pcsx2: use %ls for unicode string

%s seems to work because the printed string is single char. Let's be
pedantic
---
 pcsx2/System.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/pcsx2/System.cpp b/pcsx2/System.cpp
index 7bbeedd..0a06a91 100644
--- a/pcsx2/System.cpp
+++ b/pcsx2/System.cpp
@@ -229,7 +229,7 @@ void SysLogMachineCaps()
 	Console.Indent().WriteLn(
 		L"CPU name         =  %s\n"
 		L"Vendor/Model     =  %s (stepping %02X)\n"
-		L"CPU speed        =  %u.%03u ghz (%u logical thread%s)\n"
+		L"CPU speed        =  %u.%03u ghz (%u logical thread%ls)\n"
 		L"x86PType         =  %s\n"
 		L"x86Flags         =  %08x %08x\n"
 		L"x86EFlags        =  %08x",

From b03162747cb83f1f81bdc9630801b867e389c3e8 Mon Sep 17 00:00:00 2001
From: Gregory Hainaut <gregory.hainaut@gmail.com>
Date: Tue, 6 Jan 2015 23:45:43 +0100
Subject: [PATCH 5/6] sVU: add an option to remove it

The goal is to reduce the burden for new architecture port.

Patch is mostly inspired from 3kinox initial patch. The diff are
*/ used ifdef instead of raw removal
*/ gui don't rely on UseMicroVU* option
*/ completely remove sVU_micro.* file
---
 cmake/BuildParameters.cmake           | 11 +++++++++++
 pcsx2/CMakeLists.txt                  | 21 ++++++++++++---------
 pcsx2/System.cpp                      | 23 +++++++++++++++++++++--
 pcsx2/System.h                        |  2 ++
 pcsx2/gui/AppInit.cpp                 | 13 +++++++++++--
 pcsx2/gui/Panels/CpuPanel.cpp         | 16 ++++++++++++++++
 pcsx2/x86/iCore.h                     |  2 ++
 pcsx2/x86/iFPU.cpp                    |  6 ++++++
 pcsx2/x86/iFPU.h                      |  3 +++
 pcsx2/x86/iFPUd.cpp                   |  3 +++
 pcsx2/x86/ix86-32/iR5900-32.cpp       |  6 ++++++
 pcsx2/x86/ix86-32/iR5900Templates.cpp |  4 +++-
 pcsx2/x86/sVU_Micro.cpp               |  2 --
 pcsx2/x86/sVU_Micro.h                 |  2 --
 14 files changed, 96 insertions(+), 18 deletions(-)

diff --git a/cmake/BuildParameters.cmake b/cmake/BuildParameters.cmake
index b70158e..ce97aa1 100644
--- a/cmake/BuildParameters.cmake
+++ b/cmake/BuildParameters.cmake
@@ -18,6 +18,11 @@
 #-------------------------------------------------------------------------------
 
 #-------------------------------------------------------------------------------
+# Misc option
+#-------------------------------------------------------------------------------
+option(DISABLE_SVU "Disable superVU (don't use it)")
+
+#-------------------------------------------------------------------------------
 # Graphical option
 #-------------------------------------------------------------------------------
 option(GLSL_API "Replace zzogl CG backend by GLSL (experimental option)")
@@ -129,6 +134,9 @@ elseif(${PCSX2_TARGET_ARCHITECTURES} MATCHES "x86_64")
     # x86_64 requires -fPIC
     set(CMAKE_POSITION_INDEPENDENT_CODE ON)
 
+    # SuperVU will not be ported
+    set(DISABLE_SVU TRUE)
+
     if (DISABLE_ADVANCE_SIMD)
         set(ARCH_FLAG "-msse -msse2")
     else()
@@ -213,6 +221,9 @@ endif()
 # Set some default compiler flags
 #-------------------------------------------------------------------------------
 set(COMMON_FLAG "-pipe -std=c++0x -fvisibility=hidden -pthread")
+if (DISABLE_SVU)
+    set(COMMON_FLAG "${COMMON_FLAG} -DDISABLE_SVU")
+endif()
 set(HARDENING_FLAG "-D_FORTIFY_SOURCE=2  -Wformat -Wformat-security")
 # -Wno-attributes: "always_inline function might not be inlinable" <= real spam (thousand of warnings!!!)
 # -Wno-missing-field-initializers: standard allow to init only the begin of struct/array in static init. Just a silly warning.
diff --git a/pcsx2/CMakeLists.txt b/pcsx2/CMakeLists.txt
index 7124386..871713e 100644
--- a/pcsx2/CMakeLists.txt
+++ b/pcsx2/CMakeLists.txt
@@ -559,11 +559,15 @@ set(pcsx2x86Sources
 	x86/newVif_Dynarec.cpp
 	x86/newVif_Unpack.cpp
 	x86/newVif_UnpackSSE.cpp
+	)
+if (NOT DISABLE_SVU)
+    set(pcsx2x86Sources ${pcsx2x86Sources}
 	x86/sVU_Lower.cpp
 	x86/sVU_Micro.cpp
 	x86/sVU_Upper.cpp
 	x86/sVU_zerorec.cpp
-	)
+    )
+endif()
 
 # x86 headers
 set(pcsx2x86Headers
@@ -602,10 +606,6 @@ set(pcsx2x86Headers
 	x86/newVif.h
 	x86/newVif_HashBucket.h
 	x86/newVif_UnpackSSE.h
-	x86/sVU_Compare.h
-	x86/sVU_Debug.h
-	x86/sVU_Micro.h
-	x86/sVU_zerorec.h
 	)
 
 # colect .asm files
@@ -614,11 +614,14 @@ set(pcsx2AsmFiles
 	x86/ix86-32/aVif_proc-32.asm)
 
 # collect .S files
-set(pcsx2SSources
-	x86/aVUzerorec.S)
+if (NOT DISABLE_SVU)
+    set(pcsx2SSources x86/aVUzerorec.S)
+    # change language of .S-files to c++
+    set_source_files_properties(${pcsx2SSources} PROPERTIES LANGUAGE CXX)
+else()
+    set(pcsx2SSources "")
+endif()
 
-# change language of .S-files to c++
-set_source_files_properties(${pcsx2SSources} PROPERTIES LANGUAGE CXX)
 
 # common Sources
 set(Common
diff --git a/pcsx2/System.cpp b/pcsx2/System.cpp
index 0a06a91..25d1561 100644
--- a/pcsx2/System.cpp
+++ b/pcsx2/System.cpp
@@ -331,10 +331,11 @@ CpuInitializer< CpuType >::~CpuInitializer() throw()
 class CpuInitializerSet
 {
 public:
+#ifndef DISABLE_SVU
 	// Note: Allocate sVU first -- it's the most picky.
-
 	CpuInitializer<recSuperVU0>		superVU0;
 	CpuInitializer<recSuperVU1>		superVU1;
+#endif
 
 	CpuInitializer<recMicroVU0>		microVU0;
 	CpuInitializer<recMicroVU1>		microVU1;
@@ -491,10 +492,12 @@ bool SysCpuProviderPack::IsRecAvailable_MicroVU1() const { return CpuProviders->
 BaseException* SysCpuProviderPack::GetException_MicroVU0() const { return CpuProviders->microVU0.ExThrown; }
 BaseException* SysCpuProviderPack::GetException_MicroVU1() const { return CpuProviders->microVU1.ExThrown; }
 
+#ifndef DISABLE_SVU
 bool SysCpuProviderPack::IsRecAvailable_SuperVU0() const { return CpuProviders->superVU0.IsAvailable(); }
 bool SysCpuProviderPack::IsRecAvailable_SuperVU1() const { return CpuProviders->superVU1.IsAvailable(); }
 BaseException* SysCpuProviderPack::GetException_SuperVU0() const { return CpuProviders->superVU0.ExThrown; }
 BaseException* SysCpuProviderPack::GetException_SuperVU1() const { return CpuProviders->superVU1.ExThrown; }
+#endif
 
 
 void SysCpuProviderPack::CleanupMess() throw()
@@ -522,10 +525,16 @@ bool SysCpuProviderPack::HadSomeFailures( const Pcsx2Config::RecompilerOptions&
 {
 	return	(recOpts.EnableEE && !IsRecAvailable_EE()) ||
 			(recOpts.EnableIOP && !IsRecAvailable_IOP()) ||
+#ifndef DISABLE_SVU
 			(recOpts.EnableVU0 && recOpts.UseMicroVU0 && !IsRecAvailable_MicroVU0()) ||
 			(recOpts.EnableVU1 && recOpts.UseMicroVU0 && !IsRecAvailable_MicroVU1()) ||
 			(recOpts.EnableVU0 && !recOpts.UseMicroVU0 && !IsRecAvailable_SuperVU0()) ||
-			(recOpts.EnableVU1 && !recOpts.UseMicroVU1 && !IsRecAvailable_SuperVU1());
+			(recOpts.EnableVU1 && !recOpts.UseMicroVU1 && !IsRecAvailable_SuperVU1())
+#else
+			(recOpts.EnableVU0 && !IsRecAvailable_MicroVU0()) ||
+			(recOpts.EnableVU1 && !IsRecAvailable_MicroVU1())
+#endif
+			;
 
 }
 
@@ -541,12 +550,21 @@ void SysCpuProviderPack::ApplyConfig() const
 	CpuVU1 = CpuProviders->interpVU1;
 
 	if( EmuConfig.Cpu.Recompiler.EnableVU0 )
+#ifndef DISABLE_SVU
 		CpuVU0 = EmuConfig.Cpu.Recompiler.UseMicroVU0 ? (BaseVUmicroCPU*)CpuProviders->microVU0 : (BaseVUmicroCPU*)CpuProviders->superVU0;
+#else
+		CpuVU0 = (BaseVUmicroCPU*)CpuProviders->microVU0;
+#endif
 
 	if( EmuConfig.Cpu.Recompiler.EnableVU1 )
+#ifndef DISABLE_SVU
 		CpuVU1 = EmuConfig.Cpu.Recompiler.UseMicroVU1 ? (BaseVUmicroCPU*)CpuProviders->microVU1 : (BaseVUmicroCPU*)CpuProviders->superVU1;
+#else
+		CpuVU1 = (BaseVUmicroCPU*)CpuProviders->microVU1;
+#endif
 }
 
+#ifndef DISABLE_SVU
 // This is a semi-hacky function for convenience
 BaseVUmicroCPU* SysCpuProviderPack::getVUprovider(int whichProvider, int vuIndex) const {
 	switch (whichProvider) {
@@ -556,6 +574,7 @@ BaseVUmicroCPU* SysCpuProviderPack::getVUprovider(int whichProvider, int vuIndex
 	}
 	return NULL;
 }
+#endif
 
 // Resets all PS2 cpu execution caches, which does not affect that actual PS2 state/condition.
 // This can be called at any time outside the context of a Cpu->Execute() block without
diff --git a/pcsx2/System.h b/pcsx2/System.h
index f68dcf7..75c855d 100644
--- a/pcsx2/System.h
+++ b/pcsx2/System.h
@@ -141,7 +141,9 @@ class SysCpuProviderPack
 	virtual ~SysCpuProviderPack() throw();
 
 	void ApplyConfig() const;
+#ifndef DISABLE_SVU
 	BaseVUmicroCPU* getVUprovider(int whichProvider, int vuIndex) const;
+#endif
 
 	bool HadSomeFailures( const Pcsx2Config::RecompilerOptions& recOpts ) const;
 
diff --git a/pcsx2/gui/AppInit.cpp b/pcsx2/gui/AppInit.cpp
index 2d7cc24..b590940 100644
--- a/pcsx2/gui/AppInit.cpp
+++ b/pcsx2/gui/AppInit.cpp
@@ -167,16 +167,25 @@ void Pcsx2App::AllocateCoreStuffs()
 			{
 				scrollableTextArea->AppendText( L"* microVU0\n\t" + ex->FormatDisplayMessage() + L"\n\n" );
 				recOps.UseMicroVU0	= false;
+#ifndef DISABLE_SVU
 				recOps.EnableVU0	= recOps.EnableVU0 && m_CpuProviders->IsRecAvailable_SuperVU0();
+#else
+				recOps.EnableVU1	= false;
+#endif
 			}
 
 			if( BaseException* ex = m_CpuProviders->GetException_MicroVU1() )
 			{
 				scrollableTextArea->AppendText( L"* microVU1\n\t" + ex->FormatDisplayMessage() + L"\n\n" );
 				recOps.UseMicroVU1	= false;
+#ifndef DISABLE_SVU
 				recOps.EnableVU1	= recOps.EnableVU1 && m_CpuProviders->IsRecAvailable_SuperVU1();
+#else
+				recOps.EnableVU1	= false;
+#endif
 			}
 
+#ifndef DISABLE_SVU
 			if( BaseException* ex = m_CpuProviders->GetException_SuperVU0() )
 			{
 				scrollableTextArea->AppendText( L"* SuperVU0\n\t" + ex->FormatDisplayMessage() + L"\n\n" );
@@ -190,9 +199,9 @@ void Pcsx2App::AllocateCoreStuffs()
 				recOps.UseMicroVU1	= m_CpuProviders->IsRecAvailable_MicroVU1();
 				recOps.EnableVU1	= recOps.EnableVU1 && recOps.UseMicroVU1;
 			}
+#endif
 
-			exconf += exconf.Heading( pxE( L"Note: Recompilers are not necessary for PCSX2 to run, however they typically improve emulation speed substantially. You may have to manually re-enable the recompilers listed above, if you resolve the errors." )
-			);
+			exconf += exconf.Heading(pxE( L"Note: Recompilers are not necessary for PCSX2 to run, however they typically improve emulation speed substantially. You may have to manually re-enable the recompilers listed above, if you resolve the errors." ));
 
 			pxIssueConfirmation( exconf, MsgButtons().OK() );
 		}
diff --git a/pcsx2/gui/Panels/CpuPanel.cpp b/pcsx2/gui/Panels/CpuPanel.cpp
index 87d92f1..6ec70b9 100644
--- a/pcsx2/gui/Panels/CpuPanel.cpp
+++ b/pcsx2/gui/Panels/CpuPanel.cpp
@@ -185,8 +185,10 @@ Panels::CpuPanelVU::CpuPanelVU( wxWindow* parent )
 		RadioPanelItem(_("microVU Recompiler"))
 		.SetToolTip(_("New Vector Unit recompiler with much improved compatibility. Recommended.")),
 
+#ifndef DISABLE_SVU
 		RadioPanelItem(_("superVU Recompiler [legacy]"))
 		.SetToolTip(_("Useful for diagnosing bugs or clamping issues in the new mVU recompiler."))
+#endif
 	};
 
 	m_panel_VU0 = &(new pxRadioPanel( this, tbl_CpuTypes_VU ))	->SetDefaultItem( 1 );
@@ -274,8 +276,10 @@ void Panels::CpuPanelVU::Apply()
 	recOps.EnableVU0	= m_panel_VU0->GetSelection() > 0;
 	recOps.EnableVU1	= m_panel_VU1->GetSelection() > 0;
 
+#ifndef DISABLE_SVU
 	recOps.UseMicroVU0	= m_panel_VU0->GetSelection() == 1;
 	recOps.UseMicroVU1	= m_panel_VU1->GetSelection() == 1;
+#endif
 }
 
 void Panels::CpuPanelVU::AppStatusEvent_OnSettingsApplied()
@@ -289,21 +293,33 @@ void Panels::CpuPanelVU::ApplyConfigToGui( AppConfig& configToApply, int flags )
 	m_panel_VU1->Enable(true);
 
 	m_panel_VU0->EnableItem( 1, true);
+#ifndef DISABLE_SVU
 	m_panel_VU0->EnableItem( 2, true);
+#endif
 
 	m_panel_VU1->EnableItem( 1, true);
+#ifndef DISABLE_SVU
 	m_panel_VU1->EnableItem( 2, true);
+#endif
 
 	Pcsx2Config::RecompilerOptions& recOps( configToApply.EmuOptions.Cpu.Recompiler );
+#ifndef DISABLE_SVU
 	if( recOps.UseMicroVU0 )
 		m_panel_VU0->SetSelection( recOps.EnableVU0 ? 1 : 0 );
 	else
 		m_panel_VU0->SetSelection( recOps.EnableVU0 ? 2 : 0 );
+#else
+	m_panel_VU0->SetSelection( recOps.EnableVU0 ? 1 : 0 );
+#endif
 
+#ifndef DISABLE_SVU
 	if( recOps.UseMicroVU1 )
 		m_panel_VU1->SetSelection( recOps.EnableVU1 ? 1 : 0 );
 	else
 		m_panel_VU1->SetSelection( recOps.EnableVU1 ? 2 : 0 );
+#else
+	m_panel_VU1->SetSelection( recOps.EnableVU1 ? 1 : 0 );
+#endif
 
 	this->Enable(!configToApply.EnablePresets);
 	m_panel_VU0->Enable(!configToApply.EnablePresets);
diff --git a/pcsx2/x86/iCore.h b/pcsx2/x86/iCore.h
index 388e418..665cb31 100644
--- a/pcsx2/x86/iCore.h
+++ b/pcsx2/x86/iCore.h
@@ -50,7 +50,9 @@
 
 // used in VU recs
 #define PROCESS_VU_UPDATEFLAGS 0x10
+#ifndef DISABLE_SVU
 #define PROCESS_VU_SUPER	0x40 // set if using supervu recompilation
+#endif
 #define PROCESS_VU_COP2		0x80 // simple cop2
 
 #define EEREC_S (((info)>>8)&0xf)
diff --git a/pcsx2/x86/iFPU.cpp b/pcsx2/x86/iFPU.cpp
index 1c9999c..d069f72 100644
--- a/pcsx2/x86/iFPU.cpp
+++ b/pcsx2/x86/iFPU.cpp
@@ -20,10 +20,16 @@
 #include "R5900OpcodeTables.h"
 #include "iR5900.h"
 #include "iFPU.h"
+
+#ifndef DISABLE_SVU
 #include "sVU_Micro.h"
+#endif
 
 using namespace x86Emitter;
 
+const __aligned16 u32 g_minvals[4]	= {0xff7fffff, 0xff7fffff, 0xff7fffff, 0xff7fffff};
+const __aligned16 u32 g_maxvals[4]	= {0x7f7fffff, 0x7f7fffff, 0x7f7fffff, 0x7f7fffff};
+
 //------------------------------------------------------------------
 namespace R5900 {
 namespace Dynarec {
diff --git a/pcsx2/x86/iFPU.h b/pcsx2/x86/iFPU.h
index 8f7e6f8..bd5a0ae 100644
--- a/pcsx2/x86/iFPU.h
+++ b/pcsx2/x86/iFPU.h
@@ -16,6 +16,9 @@
 #ifndef __IFPU_H__
 #define __IFPU_H__
 
+extern const __aligned16 u32 g_minvals[4];
+extern const __aligned16 u32 g_maxvals[4];
+
 namespace R5900 {
 namespace Dynarec {
 
diff --git a/pcsx2/x86/iFPUd.cpp b/pcsx2/x86/iFPUd.cpp
index bd89b39..f2a20dd 100644
--- a/pcsx2/x86/iFPUd.cpp
+++ b/pcsx2/x86/iFPUd.cpp
@@ -21,7 +21,10 @@
 #include "x86emitter/x86emitter.h"
 #include "iR5900.h"
 #include "iFPU.h"
+
+#ifndef DISABLE_SVU
 #include "sVU_Micro.h"
+#endif
 
 /* This is a version of the FPU that emulates an exponent of 0xff and overflow/underflow flags */
 
diff --git a/pcsx2/x86/ix86-32/iR5900-32.cpp b/pcsx2/x86/ix86-32/iR5900-32.cpp
index c4bbfd1..768ee5c 100644
--- a/pcsx2/x86/ix86-32/iR5900-32.cpp
+++ b/pcsx2/x86/ix86-32/iR5900-32.cpp
@@ -1972,8 +1972,10 @@ static void __fastcall recRecompile( const u32 startpc )
 
 		for(i = startpc; i < s_nEndBlock; i += 4) {
 
+#ifndef DISABLE_SVU
 			// superVU hack: it needs vucycles, for some reason. >_<
 			extern int vucycle;
+#endif
 
 			g_pCurInstInfo++;
 			cpuRegs.code = *(u32*)PSM(i);
@@ -1983,7 +1985,9 @@ static void __fastcall recRecompile( const u32 startpc )
 
 				if( !usecop2 ) {
 					// init
+#ifndef DISABLE_SVU
 					vucycle = 0;
+#endif
 					usecop2 = 1;
 				}
 
@@ -1992,9 +1996,11 @@ static void __fastcall recRecompile( const u32 startpc )
 				continue;
 			}
 
+#ifndef DISABLE_SVU
 			// fixme - This should be based on the cycle count of the current EE
 			// instruction being analyzed.
 			if( usecop2 ) vucycle++;
+#endif
 
 		}
 		// This *is* important because g_pCurInstInfo is checked a bit later on and
diff --git a/pcsx2/x86/ix86-32/iR5900Templates.cpp b/pcsx2/x86/ix86-32/iR5900Templates.cpp
index 07928cb..1d4ab4a 100644
--- a/pcsx2/x86/ix86-32/iR5900Templates.cpp
+++ b/pcsx2/x86/ix86-32/iR5900Templates.cpp
@@ -22,11 +22,13 @@
 #include "iMMI.h"
 #include "iFPU.h"
 #include "iCOP0.h"
-#include "sVU_Micro.h"
 #include "VU.h"
 #include "VUmicro.h"
 
+#ifndef DISABLE_SVU
+#include "sVU_Micro.h"
 #include "sVU_zerorec.h"
+#endif
 
 #include "vtlb.h"
 
diff --git a/pcsx2/x86/sVU_Micro.cpp b/pcsx2/x86/sVU_Micro.cpp
index e1021cc..2be3bdf 100644
--- a/pcsx2/x86/sVU_Micro.cpp
+++ b/pcsx2/x86/sVU_Micro.cpp
@@ -88,8 +88,6 @@ int vucycle;
 const __aligned16 float s_fones[8]	= {1.0f, 1.0f, 1.0f, 1.0f, -1.0f, -1.0f, -1.0f, -1.0f};
 const __aligned16 u32 s_mask[4]		= {0x007fffff, 0x007fffff, 0x007fffff, 0x007fffff};
 const __aligned16 u32 s_expmask[4]	= {0x7f800000, 0x7f800000, 0x7f800000, 0x7f800000};
-const __aligned16 u32 g_minvals[4]	= {0xff7fffff, 0xff7fffff, 0xff7fffff, 0xff7fffff};
-const __aligned16 u32 g_maxvals[4]	= {0x7f7fffff, 0x7f7fffff, 0x7f7fffff, 0x7f7fffff};
 const __aligned16 u32 const_clip[8]	= {0x7fffffff, 0x7fffffff, 0x7fffffff, 0x7fffffff,
 									   0x80000000, 0x80000000, 0x80000000, 0x80000000};
 
diff --git a/pcsx2/x86/sVU_Micro.h b/pcsx2/x86/sVU_Micro.h
index 587f50e..2a528f0 100644
--- a/pcsx2/x86/sVU_Micro.h
+++ b/pcsx2/x86/sVU_Micro.h
@@ -59,8 +59,6 @@ extern vFloat vFloats4_useEAX[16];
 extern const __aligned16 float s_fones[8];
 extern const __aligned16 u32 s_mask[4];
 extern const __aligned16 u32 s_expmask[4];
-extern const __aligned16 u32 g_minvals[4];
-extern const __aligned16 u32 g_maxvals[4];
 extern const __aligned16 u32 const_clip[8];
 
 u32 GetVIAddr(VURegs * VU, int reg, int read, int info);

From 149940ffda25a4b5af41aca29b0583da8e0060bc Mon Sep 17 00:00:00 2001
From: Johannes Obermayr <johannesobermayr@gmx.de>
Date: Fri, 16 Jan 2015 20:57:09 +0100
Subject: [PATCH 6/6] common: gcc can't inline a couple of function

=> "can never be inlined because it uses variable argument lists"
---
 common/src/Utilities/FastFormatString.cpp | 13 ++++++++++---
 1 file changed, 10 insertions(+), 3 deletions(-)

diff --git a/common/src/Utilities/FastFormatString.cpp b/common/src/Utilities/FastFormatString.cpp
index 477836e..c6b7b72 100644
--- a/common/src/Utilities/FastFormatString.cpp
+++ b/common/src/Utilities/FastFormatString.cpp
@@ -150,8 +150,11 @@ class GlobalBufferManager
 static bool buffer_is_avail = false;
 static GlobalBufferManager< BaseTlsVariable< FastFormatBuffers > > m_buffer_tls(buffer_is_avail);
 
-//static __ri void format_that_ascii_mess( SafeArray<char>& buffer, uint writepos, const char* fmt, va_list argptr )
-static __ri void format_that_ascii_mess( CharBufferType& buffer, uint writepos, const char* fmt, va_list argptr )
+static
+#ifndef __linux__
+__ri
+#endif
+void format_that_ascii_mess( CharBufferType& buffer, uint writepos, const char* fmt, va_list argptr )
 {
 	va_list args;
 	while( true )
@@ -186,7 +189,11 @@ static __ri void format_that_ascii_mess( CharBufferType& buffer, uint writepos,
 }
 
 // returns the length of the formatted string, in characters (wxChars).
-static __ri uint format_that_unicode_mess( CharBufferType& buffer, uint writepos, const wxChar* fmt, va_list argptr)
+static
+#ifndef __linux__
+__ri
+#endif
+uint format_that_unicode_mess( CharBufferType& buffer, uint writepos, const wxChar* fmt, va_list argptr)
 {
 	va_list args;
 	while( true )
