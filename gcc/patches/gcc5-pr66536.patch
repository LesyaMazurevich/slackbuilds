From 33f9ee96d5fad6b422ffe0632b6c7bfb1d60c371 Mon Sep 17 00:00:00 2001
From: jason <jason@138bc75d-0d04-0410-961f-82ee72b054a4>
Date: Wed, 17 Jun 2015 14:33:23 +0000
Subject: [PATCH] 	PR c++/66536 	* tree.c (replace_placeholders_r)
 [CONSTRUCTOR]: Handle type 	mismatch.

git-svn-id: svn+ssh://gcc.gnu.org/svn/gcc/branches/gcc-5-branch@224560 138bc75d-0d04-0410-961f-82ee72b054a4
---
 gcc/cp/ChangeLog                         |  4 ++++
 gcc/cp/tree.c                            |  7 ++++++-
 gcc/testsuite/g++.dg/cpp1y/var-templ30.C | 19 +++++++++++++++++++
 3 files changed, 29 insertions(+), 1 deletion(-)
 create mode 100644 gcc/testsuite/g++.dg/cpp1y/var-templ30.C

diff --git a/gcc/cp/ChangeLog b/gcc/cp/ChangeLog
index f374338..9a9be0e 100644
--- a/gcc/cp/ChangeLog
+++ b/gcc/cp/ChangeLog
@@ -1,5 +1,9 @@
 2015-06-17  Jason Merrill  <jason@redhat.com>
 
+	PR c++/66536
+	* tree.c (replace_placeholders_r) [CONSTRUCTOR]: Handle type
+	mismatch.
+
 	PR c++/58063
 	* tree.c (bot_manip): Remap SAVE_EXPR.
 
diff --git a/gcc/cp/tree.c b/gcc/cp/tree.c
index e1301b2..baf5d29 100644
--- a/gcc/cp/tree.c
+++ b/gcc/cp/tree.c
@@ -2540,7 +2540,12 @@ replace_placeholders_r (tree* t, int* walk_subtrees, void* data_)
 	    if (TREE_CODE (*valp) == CONSTRUCTOR
 		&& AGGREGATE_TYPE_P (type))
 	      {
-		subob = build_ctor_subob_ref (ce->index, type, obj);
+		/* If we're looking at the initializer for OBJ, then build
+		   a sub-object reference.  If we're looking at an
+		   initializer for another object, just pass OBJ down.  */
+		if (same_type_ignoring_top_level_qualifiers_p
+		    (TREE_TYPE (*t), TREE_TYPE (obj)))
+		  subob = build_ctor_subob_ref (ce->index, type, obj);
 		if (TREE_CODE (*valp) == TARGET_EXPR)
 		  valp = &TARGET_EXPR_INITIAL (*valp);
 	      }
diff --git a/gcc/testsuite/g++.dg/cpp1y/var-templ30.C b/gcc/testsuite/g++.dg/cpp1y/var-templ30.C
new file mode 100644
index 0000000..e89aa7c
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp1y/var-templ30.C
@@ -0,0 +1,19 @@
+// PR c++/66536
+// { dg-do compile { target c++14 } }
+
+template <typename> struct make_impl;
+struct Tuple;
+template <> struct make_impl<Tuple> {};
+struct A {
+  template <typename X> auto operator()(X) { return make_impl<Tuple>(); }
+};
+template <typename> A make;
+template <typename _Tp, int> struct array { _Tp _M_elems; };
+struct Tracked {
+  Tracked(int);
+};
+struct B {
+  Tracked tracker{0};
+};
+template <int> using ct_eq = B;
+auto eq_arrays = make<Tuple>(array<ct_eq<0>, 0>{});
-- 
1.9.4

