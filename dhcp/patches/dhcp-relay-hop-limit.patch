From f3d697a84e90f31a86874e334240ee1360a2fbf8 Mon Sep 17 00:00:00 2001
From: Jiri Popelka <jpopelka@redhat.com>
Date: Thu, 9 Oct 2014 18:57:22 +0200
Subject: [PATCH] Work-around for hop-limit set to 1

---
 common/socket.c | 16 +++++++++++++++-
 1 file changed, 15 insertions(+), 1 deletion(-)

diff --git a/common/socket.c b/common/socket.c
index b8b44a6..93406ef 100644
--- a/common/socket.c
+++ b/common/socket.c
@@ -301,7 +301,21 @@ if_register_socket(struct interface_info *info, int family,
 	}
 
 	if ((family == AF_INET6) &&
-	    ((info->flags & INTERFACE_UPSTREAM) != 0)) {
+	    /*
+	     * rfc3315 says that: "If relay agent relays messages to
+	     * All_DHCP_Servers multicast address or other multicast addresses,
+	     * it sets the Hop Limit field to 32."
+	     *
+	     * Because we use the same socket for all (upper/lower)
+	     * interfaces, the hop limit is the same for both/all.
+	     * There should be INTERFACE_UPSTREAM in the below condition, but
+	     * problem is when the interface which registers the socket is
+	     * lower interface, in that case the hop limit was not set
+	     * (i.e. set to 1) for both.
+	     * Because rfc doesn't say anything about hop limit for lower,
+	     * it'd be lesser evil to have 32 in both cases.
+	     */
+	    ((info->flags & INTERFACE_STREAMS) != 0)) {
 		int hop_limit = 32;
 		if (setsockopt(sock, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,
 			       &hop_limit, sizeof(int)) < 0) {
-- 
2.1.0

